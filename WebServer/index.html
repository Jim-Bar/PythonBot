<!DOCTYPE html>
<html lang="en">
 
<head>
  <meta charset="utf-8">
  <title>PythonBot Online</title>
 
  <link rel="stylesheet" href="codemirror-5.5/lib/codemirror.css">
 
  <script src="codemirror-5.5/lib/codemirror.js"></script>
  <script src="codemirror-5.5/mode/python/python.js"></script>
  <script src="websockify/include/websock.js"></script>
  <script src="websockify/include/util.js"></script>
  <script src="pixi.min.js"></script>
</head>
 
<body>  
  
  <textarea id="editor" autofocus>def main(bot):&#13;&#10;  while True:&#13;&#10;    bot.skip()</textarea>
  <button onclick="enter_arena();">Enter arena !</button>
  <button onclick="connect_to_the_game();">Connect to the game</button>
  <button onclick="exit_arena();">Exit arena</button>
  <script>
    var editor = CodeMirror.fromTextArea(document.getElementById("editor"), {tabSize: 2, lineNumbers: true, undoDepth: 1000});
    
    var game = {};
    
    function enter_arena() {
      open_websocket();
    }

    function open_websocket() {
      var botCodeSocket = new Websock();
      botCodeSocket.open("ws://127.0.0.1:5005");
      
      botCodeSocket.on("open", function () {
	console.log("'botCodeSocket' Connected");
	send_bot_code(botCodeSocket);
      });
      
      botCodeSocket.on("message", function () {
	console.log("'botCodeSocket' Received a message");
      });
      
      botCodeSocket.on("close", function (event) {
	botCodeSocket.close();
	console.log("'botCodeSocket' Disconnected with event: " + event);
      });
      
      botCodeSocket.on("error", function (error) {
	console.error("'botCodeSocket' Error: " + error);
      });
    }
    
    function send_bot_code(botCodeSocket) {
      var botCode = editor.getValue();
      botCodeSocket.send_string(botCode);
      console.log("'botCodeSocket' Sent:\n" + botCode);
    }
    
    var gameSocket = undefined;
    function connect_to_the_game() {
      var initialStateReceived = false;
    
      gameSocket = new Websock();
      gameSocket.open("ws://127.0.0.1:6005");
      
      gameSocket.on("open", function () {
	console.log("'gameSocket' Connected");
      });
      
      gameSocket.on("message", function () {
	if (initialStateReceived) {
	  receive_current_state(gameSocket);
	  update_bots(game);
	}
	else {
	  receive_initial_state(gameSocket);
	  initialStateReceived = true;
	}
      });
      
      gameSocket.on("close", function (event) {
	gameSocket.close();
	console.log("'gameSocket' Disconnected with event: " + event);
      });
      
      gameSocket.on("error", function (error) {
	console.error("'gameSocket' Error: " + error);
      });
    }
    
    function exit_arena() {
      gameSocket.close();
    }

    function receive_current_state(gameSocket) {    
      // The bots.
      var buffer = 0;
      for (i = 0; i < game.numBots; i++) {
	// The first 4 bytes.
	buffer = gameSocket.rQshift8();
	if (i == 0) { // The pause bit is merged into the block of the first bot.
	  game.paused = (buffer >> 7) == 1;
	}
	var botColor = (buffer >> 1) & 0x3F; // 0X3F is 111111.
	game.bots[botColor].rotation = (buffer & 1) << 8;
	game.bots[botColor].rotation |= gameSocket.rQshift8();
	buffer = gameSocket.rQshift8();
	game.bots[botColor].alive = (buffer >> 7) == 1;
	game.bots[botColor].scanned = ((buffer >> 6) & 1) == 1;
	game.bots[botColor].life = (buffer >> 2) & 0xF; // 0xF is 1111.
	game.bots[botColor].kills = (buffer & 0x3) << 4; // 0x3 is 11.
	buffer = gameSocket.rQshift8();
	game.bots[botColor].kills |= buffer >> 4;
	game.bots[botColor].bullets = buffer & 0xF; // 0xF is 1111.
	
	// The position.
	game.bots[botColor].x = gameSocket.rQshift16();
	game.bots[botColor].y = gameSocket.rQshift16();
	
	// The scan, if applicable.
	if (game.bots[botColor].scanned) {
	  game.bots[botColor].scan.x = gameSocket.rQshift16();
	  game.bots[botColor].scan.y = gameSocket.rQshift16();
	  game.bots[botColor].scan.radius = gameSocket.rQshift16();
	}
      }
      
      // The bullets (the bullets are completely overwritten each iteration because their complete state is sent at each iteration).
      game.bullets = [];
      game.numBullets = gameSocket.rQshift8();
      for (i = 0; i < game.numBullets; i++) {
	game.bullets[i] = {};
	game.bullets[i].x = gameSocket.rQshift16();
	game.bullets[i].y = gameSocket.rQshift16();
      }
      
      // The explosions (PARTIALLY IMPLEMENTED: SHOULD BE KEPT FROM A ITERATION TO ANOTHER).
      game.explosions = [];
      game.numExplosions = gameSocket.rQshift8();
      for (i = 0; i < game.numExplosions; i++) {
	game.explosions[i] = {};
	game.explosions[i].x = gameSocket.rQshift16();
	game.explosions[i].y = gameSocket.rQshift16();
      }
      game.botExplosions = [];
      game.numBotExplosions = gameSocket.rQshift8();
      for (i = 0; i < game.numBotExplosions; i++) {
	game.botExplosions[i] = {};
	game.botExplosions[i].x = gameSocket.rQshift16();
	game.botExplosions[i].y = gameSocket.rQshift16();
      }
    }
    
    function receive_initial_state(gameSocket) {
      game.width = gameSocket.rQshift16();
      game.height = gameSocket.rQshift16();
      game.numWalls = gameSocket.rQshift8();
      game.numBots = gameSocket.rQshift8();
      
      game.walls = [];
      for (i = 0; i < game.numWalls; i++) {
        game.walls[i] = {};
	game.walls[i].x = gameSocket.rQshift16();
	game.walls[i].y = gameSocket.rQshift16();
	game.walls[i].radius = gameSocket.rQshift8();
      }
      
      game.bots = [];
      for (i = 0; i < game.numBots; i++) {
	var botColor = gameSocket.rQshift8();
	game.bots[botColor] = {};
	game.bots[botColor].alive = true;
	game.bots[botColor].scanned = false;
	game.bots[botColor].life = 10;
	game.bots[botColor].kills = 0;
	game.bots[botColor].bullets = 10;
	game.bots[botColor].scan = {};
	game.bots[botColor].color = botColor;
	game.bots[botColor].x = gameSocket.rQshift16();
	game.bots[botColor].y = gameSocket.rQshift16();
	game.bots[botColor].rotation = gameSocket.rQshift16();
	var nameLength = gameSocket.rQshift8();
	game.bots[botColor].name = gameSocket.rQshiftStr(nameLength);
      }
      
      console.log("Initial game state:");
      console.log(game);
      
      create_view(game);
    }
  </script>
  
  <script>
    function get_color(colorId) {
      switch (colorId) {
	case 0:
	  return 0xFF0000;
	case 1:
	  return 0x00FF00;
	case 2:
	  return 0x0000FF;
	case 3:
	  return 0xFFFF00;
	case 4:
	  return 0xFF00FF;
	case 5:
	  return 0x00FFFF;
	case 6:
	  return 0xFF8000;
	case 7:
	  return 0x8000FF;
	default:
	  console.error("Unknown color: " + colorId);
	  return 0x808080; // Grey.
      }
    }
  
    function degrees_to_radians(degrees) {
      return degrees * Math.PI / 180;
    };
  
    function create_view(game) {
      // create an new instance of a pixi container.
      var container = new PIXI.Container();
  
      // create a renderer instance.
      var renderer = PIXI.autoDetectRenderer(game.width, game.height, {antialias: true});
      renderer.backgroundColor = 0xFFFFFF;
  
      // add the renderer view element to the DOM
      document.body.appendChild(renderer.view);
  
      create_bots(game, container);
      create_walls(game, container);
  
      requestAnimFrame(animate);
      function animate() {
	  requestAnimFrame(animate);
	  renderer.render(container);
      }
    }
    
    function create_bots(game, container) {
      var botLength = 20;
      var botWidth = 2 * botLength / 3.5;
      for (i = 0; i < game.numBots; i++) {
	// Triangle.
	game.bots[i].graphics = new PIXI.Graphics();
	game.bots[i].graphics.beginFill(get_color(game.bots[i].color));
	game.bots[i].graphics.moveTo(0, - 2 * botLength / 3);
	game.bots[i].graphics.lineTo(- botWidth / 2, botLength / 3);
	game.bots[i].graphics.lineTo(botWidth / 2, botLength / 3);
	game.bots[i].graphics.endFill();
	game.bots[i].graphics.cacheAsBitmap = true; // Useful for antialiasing if the shape is not redraw (that's the case).
	
	// Scan.
	game.bots[i].scan.graphics = new PIXI.Graphics(); // Nothing to draw until the bot scan.
	
	container.addChild(game.bots[i].graphics);
	container.addChild(game.bots[i].scan.graphics);
      }
      
      update_bots(game);
    }
    
    function update_bots(game) {
      for (i = 0; i < game.numBots; i++) {	
	game.bots[i].graphics.position.x = game.bots[i].x;
	game.bots[i].graphics.position.y = game.bots[i].y;
	game.bots[i].graphics.rotation = degrees_to_radians(game.bots[i].rotation);
	
	if (game.bots[i].scanned) {
	  game.bots[i].scan.graphics.clear();
	  game.bots[i].scan.graphics.lineStyle(1, get_color(game.bots[i].color));
	  game.bots[i].scan.graphics.drawCircle(game.bots[i].scan.x, game.bots[i].scan.y, game.bots[i].scan.radius);
	  game.bots[i].scan.graphics.endFill();
	}
      }
    }
    
    function create_walls(game, container) {
      for (i = 0; i < game.numWalls; i++) {
	game.walls[i].graphics = new PIXI.Graphics();
	game.walls[i].graphics.beginFill(0x808080);
	game.walls[i].graphics.drawCircle(game.walls[i].x, game.walls[i].y, game.walls[i].radius);
	game.walls[i].graphics.endFill();
	game.walls[i].graphics.cacheAsBitmap = true;
	container.addChild(game.walls[i].graphics);
      }
    }
  </script>
 
</body>
</html>
